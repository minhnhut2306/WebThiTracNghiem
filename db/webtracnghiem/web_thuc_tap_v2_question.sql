-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: web_thuc_tap_v2
-- ------------------------------------------------------
-- Server version	5.7.41-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `question`
--

DROP TABLE IF EXISTS `question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `question` (
  `ques_id` int(11) NOT NULL AUTO_INCREMENT,
  `ans` int(11) NOT NULL,
  `chose` int(11) NOT NULL,
  `level` int(11) NOT NULL,
  `optiona` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
  `optionb` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
  `optionc` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
  `optiond` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
  `title` text CHARACTER SET utf8 COLLATE utf8_unicode_ci,
  `lesson_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`ques_id`),
  KEY `FK1sbknhfhhug49n0elkvgk38vs` (`lesson_id`),
  CONSTRAINT `FK1sbknhfhhug49n0elkvgk38vs` FOREIGN KEY (`lesson_id`) REFERENCES `lesson` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question`
--

LOCK TABLES `question` WRITE;
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` VALUES (1,2,2,1,'Cấu trúc dữ liệu + giải thuật = chương trình','Cấu trúc dữ liệu + chương trình = giải thuật','Chương trình + Giải thuât = Cấu trúc dữ liệu','Cấu trúc dữ liệu = Chương trình','Mối quan hệ giữa cấu trúc dữ liệu giải thuật có thể minh họa bằng đẳng thức nào?',1),(2,4,4,1,'Trong giải thuật của nó có lời gọi tới một giải thuật khác đã biết kết quả.','Trong giải thuật của nó có lời gọi tới chính nó nhưng với phạm vi lớn hơn','Trong giải thuật của nó có lời gọi tới chính nó.','Trong giải thuật của nó có lời gọi tới chính nó nhưng với phạm vi nhỏ hơn','Giải thuật đệ quy là:',1),(3,2,2,1,'Danh sách tuyến tính là một danh sách có dạng (a1, a2, ..., an)','Danh sách mà quan hệ lân cận giữa các phần tử được xác định','Danh sách dạng được lưu dưới dạng mảng.','Danh sách tuyến tính là một danh sách rỗng.','Danh sách tuyến tính là',1),(4,1,1,1,'việc truy nhập vào phần tử của mảng được thực hiện trực tiếp dựa vào địa chỉ tính được (chỉ số), nên tốc độ nhanh và đồng đều đối với mọi phần tử.','Có thể thay đổi số lượng phần tử theo ý muốn của người dùng','Có thể bổ sung hoặc xóa một phần tử bất kỳ trong mảng.','Tất cả các ý trên đều đúng','ưu điểm của việc cài đặt danh sách bằng mảng',1),(5,4,4,1,'Là một danh sách tuyến tính trong đó phép bổ sung sung một phần tử vào ngăn xếp được thực hiện ở một đầu, Và phép loại bỏ không thực hiện được','Là một danh sách tuyến tính trong đó phép bổ sung một phần tử vào ngăn xếp và phéploại bỏ một phần tử khỏi ngăn xếp luôn luôn thực hiện ở tại một vị trí bất kì trong danh sách','Là một danh sách tuyến tính trong đó phép bổ sung một phần tử vào ngăn xếp được thực hiện ở một đầu , và phép loại bỏ được thực hiện ở đầu kia','Là một danh sách tuyến tính trong đó phép bổ sung một phần tử vào ngăn xếp và phép loại bỏ một phần tử khỏi ngăn xếp luôn luôn thực hiện ở một đầu gọi là đỉnh ','Danh sách tuyến tính dạng ngăn xếp là',1),(6,4,4,1,'FIFO( first in first out)','LILO(last in last out)','FOLO( fisrt out last out)','LIFO(last in first out)','Danh sách tuyến tính dạng ngăn xếp làm việc theo nguyên tắc',1),(7,3,3,1,'Mảng (array)','Hàng đợi(Queue)','Ngăn xếp (stack)','Bản gCâu Record)','Khi đổi một số nguyên từ hệ thập phân sang hệ nhị phân thì người ta dùng phép chia liên tiếp cho 2 và lấy các số dư (là các chữ số nhị phân) theo chiều ngược lại. Cơ chế sắp xếp này chính là cơ chế hoạt động của cấu trúc dữ liệu',1),(8,3,3,1,'Là một danh sách tuyến tính trong đó phép bổ sung một phần tử và phép loại bỏ một phần tử được thực hiện ở tại một vị trí bất kì trong danh sách','Hàng đợi là kiểu danh sách tuyến tính trong đó, phép bổ sung một phần tử được thực hiện ở một đầu, gọi là lối sau (rear) hay lối trước (front). Phép loại bỏ không thực hiệnđược.','Hàng đợi là kiểu danh sách tuyến tính trong đó, phép bổ sung phần tử ở một đầu, gọilà lối sau (rear) và phép loại bỏ phần tử được thực hiện ở đầu kia, gọi là lối trước (front)','Hàng đợi là kiểu danh sách tuyến tính trong đó, phép bổ sung một phần tử hay loại bỏđược thực hiện ở một đầu danh sách gọi là đỉnh (Top)','định nghĩa danh sách tuyến tính Hàng đợi (Queue)',1),(9,4,4,1,'LOLO','FILO','LIFO','FIFO',' Hàng đợi còn được gọi là danh sách kiểu:',1),(10,3,3,1,'EMPTY(x)','TOP(x)','PUSH(x)','POP(x)','Để thêm một đối tượng x bất kỳ vào Stack, thao tác thường dùng là:',1),(11,3,3,1,'FULL(x)','EMPTY(x)','POP(x)','PUSH(x)','Để lấy loại bỏ một đối tượng ra khỏi Stack, thao tác thường dùng là:',1),(12,2,2,1,'Kiểu bản ghi','Danh sách móc nối và mảng dữ liệu','Danh sách móc nối','Mảng dữ liệu','Để biểu diễn Stack, ta thường sử dụng kiểu dữ liệu nào sau đây?',1),(13,4,4,1,'Xóa bỏ một phần tử bất kì khỏi Stack','Xóa bỏ một dãy các phần tử ra khỏi Stack','Lấy phần tử đầu tiên ra khỏi Stack','Lấy một phần tử cuối cùng ra khỏi đỉnh Stack','Thao tác POP(x) dùng trong Stack là để:',1),(14,3,3,1,'Bổ sung một dãy các phần tử vào đỉnh Stack.','Bổ sung một phần tử bất kì vào Stack','Bổ sung một phần tử vào đỉnh Stack','Bổ sung một phần tử vào đầu Stack','Thao tác Push(x) dùng trong Stack là để',1),(15,3,3,1,'POP(23),PUSH(25)','POP(25),PUSH(23)','POP(25),POP(23), PUSH(25)','POP(25),POP(23)','Cho Stack gồm 5 phần tử {12, 5, 20, 23, 25}, trong đó 25 là phần tử ở đỉnh Stack. Đểlấy ra phần tử thứ 4 trong Stack ta phải làm thế nào?',1),(16,2,2,1,'POP(25),POP(23), PUSH(23)','POP(25)','POP(23),PUSH(25)','POP(25),PUSH(23)','Cho Stack gồm 5 phần tử {12, 5, 20, 23, 25}, trong đó 25 là phần tử ở đỉnh Stack. Đểlấy ra phần tử thứ 5 trong Stack ta phải làm thế nào?',1),(17,1,1,1,'POP(25), POP(23), POP(20), PUSH(23), PUSH(25)','POP(25), POP(23), PUSH(20), PUSH(25), PUSH(23)','POP(25), POP(23), POP(20)','POP(25), POP(23), POP(20), PUSH(25), PUSH(23)','Cho Stack gồm 5 phần tử {12, 5, 20, 23, 25}, trong đó 25 là phần tử ở đỉnh Stack. Đểlấy ra phần tử thứ 3 trong Stack ta phải làm thế nào?',1),(18,3,3,1,'Kiểm tra Stack có tràn không','Kiểm tra Stack có cạn không','Bổ sung một phần tử vào Stack','Loại bỏ một phân tử ra khỏi Stack','Trong lưu trữ dữ liệu kiểu Stack, giải thuật sau thực hiện công việc gì?Procedure F(X) BeginT:=T+1; S[T]:=X; End;',1),(19,3,3,1,'Bổ sung một phần tử ra khỏi Stack','Kiểm tra Stack có cạn không','Loại bỏ một phần tử vào Stack','Kiểm tra Stack có tràn không','Trong lưu trữ dữ liệu kiểu Stack, giải thuật sau thực hiện công việc gì? Function PBeginT:=T-1; P:=S[t+1]; End',1),(20,1,1,1,'Queue rỗng','Kiểm tra chỉ số trước và chỉ số sau của Queue có bằng nhau không','Queue tràn','Đặt phần tử đầu và phần tử cuối của Queue bằng 0','Trong lưu trữ dữ liệu kiểu Queue (Q) dưới dạng mảng nối vòng, giả sử F là con trỏ trỏ tới lối trước của Q, R là con trỏ trỏ tới lối sau của Q. Điều kiện F=R=0 nghĩa là:',1),(21,2,2,1,'F=F+1, R không thay đổi','F không thay đổi, R=R+1','F=F-1, R không thay đổi','F không thay đổi, R=R-1','Trong lưu trữ dữ liệu kiểu Queue (Q), giả sử F là con trỏ trỏ tới lối trước của Q, R là con trỏ trỏ tới lối sau của Q. Khi thêm một phần tử vào Queue, thì R và F thay đổi thế nào?',1),(22,4,4,1,'F=F-1, R không thay đổi','F không thay đổi, R=R+1','F không thay đổi, R=R-1','F=F+1, R không thay đổi','Trong lưu trữ dữ liệu kiểu Queue (Q), giả sử F là con trỏ trỏ tới lối trước của Q, R là con trỏ trỏ tới lối sau của Q. Khi loại bỏ một phần tử vào Queue, thì R và F thay đổi thế nào?',1),(23,4,4,1,'Tổng số nút trên cây','Cấp cao nhất của nút gốc','Cấp cao nhất của nút lá','Cấp cao nhất của một nút trên cây','Trong biểu diễn dữ liệu dưới dạng cây, cấp của cây chính',1),(24,1,1,1,'Lá','Không có đáp án nào đúng','Phần tử cuối cùng trong cây','Gốc','Trong biểu diễn dữ liệu dưới dạng cây, nút có cấp bằng 0 gọi là:',1),(25,4,4,1,'3 nút con','1 nút con','2 nút con','Nhiều nút con','Mỗi nút trong cây có tối đa',1),(26,3,3,1,'2*i + 1','i+1','2*i','i-1','Khi lưu trữ cây nhị phân dưới dạng mảng, nếu vị trí của nút cha trong mảng là i thì vịtrí của nút con trái là:',1),(27,4,4,1,'2*i','i+1','i-1','2*i + 1','Khi lưu trữ cây nhị phân dưới dạng mảng, nếu vị trí của nút cha trong mảng là i thì vịtí của nút con phải là:',1),(28,4,4,1,'6','7','4','6 và 7','Khi lưu trữ cây nhị phân dưới dạng mảng, nếu vị trí của nút cha trong mảng là 3 thì vị trí tương ứng của nút con sẽ là:',1),(29,2,2,1,'7','6','2','4','Khi lưu trữ cây nhị phân dưới dạng mảng, nếu vị trí của nút cha trong mảng là 3 thì vị trí tương ứng của nút con trái sẽ là',1),(30,1,1,1,'7','4','6','2','Khi lưu trữ cây nhị phân dưới dạng mảng, nếu vị trí của nút cha trong mảng là 3 thì vị trí tương ứng của nút con phải sẽ là',1),(31,2,2,1,'Duyệt cây con trái theo thứ tự trước, thăm gốc giữa, duyệt cây con phải theo thứ tự sau','Thăm gốc, duyệt cây con trái theo thứ tự trước, duyệt cây con phải theo thứ tự trước','Duyệt cây con trái theo thứ tự sau, thăm gốc trước, duyệt cây con phải theo thứ tự sau.','Thăm gốc trước, duyệt cây con trái theo thứ tự giữa, duyệt cây con phải theo thứ tự sau',' Duyệt cây nhị phân theo thứ tự trước được thực hiện theo thứ tự',1),(32,4,4,1,'Thăm gốc, duyệt cây con trái theo thứ tự giữa, duyệt cây con phải theo thứ tự giữa','Duyệt cây con trái theo thứ tự trước, thăm gốc giữa, duyệt cây con phải theo thứ tự sau','Thăm gốc trước, duyệt cây con trái theo thứ tự giữa, duyệt cây con phải theo thứ tự sau','Duyệt cây con trái theo thứ tự giữa, thăm gốc, duyệt cây con phải theo thứ tự giữa','Duyệt cây nhị phân theo thứ tự giữa được thực hiện theo thứ tự',1),(33,4,4,1,'Duyệt cây con trái theo thứ tự trước, thăm gốc giữa, duyệt cây con phải theo thứ tự sau','Thăm gốc, duyệt cây con trái theo thứ tự sau, duyệt cây con phải theo thứ tự sau.','Thăm gốc trước, duyệt cây con trái theo thứ tự giữa, duyệt cây con phải theo thứ tự sau','Duyệt cây con trái theo thứ tự sau, duyệt cây con phải theo thứ tự sau, thăm gốc','Duyệt cây nhị phân theo thứ tự sau được thực hiện theo thứ tự',1),(34,3,3,1,'Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào bé hơn được cho lên vị trí trên','Phân đoạn dãy thành nhiều dãy con và lần lượt trộn hai dãy con thành dãy lớn hơn, cho đến khi thu được dãy ban đầu đã được sắp xếp.','Chọn phần tử bé nhất xếp vào vị trí thứ nhất bằng cách đổi chổ phần tử bé nhất với phần tử thứ nhất; Tương tự đối với phần tử nhỏ thứ hai,ba..','Lần lượt lấy phần tử của danh sách chèn vị trí thích hợp của nó trong dãy','ý tưởng phương pháp sắp xếp chọn tăng dần (select sort)',1),(35,1,1,1,'Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào nhỏ hơn được đứng vị trí trên','Phân đoạn dãy thành nhiều dãy con và lần lượt trộn hai dãy con thành dãy lớn hơn, cho đến khi thu được dãy ban đầu đã được sắp xếp','Lần lượt lấy phần tử của danh sách chèn vị trí thích hợp của nó trong dãy bằng cách đẩy các phần tử lớn hơn xuống','Chọn phần tử bé nhất xếp vào vị trí thứ nhất bằng cách đổi chổ phần tử bé nhất với phần tử thứ nhấ; Tương tự đối với phần tử nhỏ thứ hai,ba...','ý tưởng phương pháp sắp xếp nổi bọt (bubble sort) là:',1),(36,3,3,1,'Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào nhỏ hơn được đứng vị trí trên.','Chọn phần tử bé nhất xếp vào vị trí thứ nhất bằng cách đổi chổ phần tử bé nhất với phần tử thứ nhấ; Tương tự đối với phần tử nhỏ thứ hai,ba...','Lần lượt lấy phần tử của danh sách chèn vị trí thích hợp của nó trong dãy bằng cách đẩy các phần tử lớn hơn xuống.','Phân đoạn dãy thành nhiều dãy con và lần lượt trộn hai dãy con thành dãy lớn hơn, cho đến khi thu được dãy ban đầu đã được sắp xếp.','ý tưởng phương pháp sắp xếp chèn (insertion sort) là',1),(37,3,3,1,'Chọn phần tử bé nhất xếp vào vị trí thứ nhất bằng cách đổi chổ phần tử bé nhất với phần tử thứ nhấ; Tương tự đối với phần tử nhỏ thứ hai,ba','Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào nhỏ hơn được đứng vị trí trên','Lần lượt chia dãy phần tử thành hai dãy con bởi một phần tử khoá (dãy con trước khoá gồm các phần tử nhỏ hơn khoá và dãy còn lại gồm các phần tử lớn hơn khoá).','Phân đoạn dãy thành nhiều dãy con và lần lượt trộn hai dãy con thành dãy lớn hơn, cho đến khi thu được dãy ban đầu đã được sắp xếp.','ý tưởng phương pháp sắp xếp nhanh (Quick sort) là',1),(38,1,1,1,'Phân đoạn','Chèn','Trộn','Vun đống','Phương pháp sắp xếp nhanh (Quick sort) chính là phương pháp:',1),(39,4,4,1,'Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào nhỏ hơn được đứng vị trí trên','Lần lượt chia dãy phần tử thành hai dãy con bởi một phần tử khoá (dãy con trước khoá gồm các phần tử nhỏ hơn khoá và dãy còn lại gồm các phần tử lớn hơn khoá)','Chọn phần tử bé nhất xếp vào vị trí thứ nhất bằng cách đổi chổ phần tử bé nhất với phần tử thứ nhất; Tương tự đối với phần tử nhỏ thứ hai,ba.','Phân đoạn dãy thành nhiều dãy con và lần lượt trộn hai dãy con thành dãy lớn hơn, cho đến khi thu được dãy ban đầu đã được sắp xếp',' ý tưởng phương pháp sắp xếp Trộn (Merge sort) là',1),(40,1,1,1,'Lần lượt tạo đống cho cây nhị phân (phần tử gốc có giá trị lớn nhất) và loại phần tử gốc ra khỏi cây đưa vào dãy sắp xếp','Bắt đầu từ cuối dãy đến đầu dãy, ta lần lượt so sánh hai phần tử kế tiếp nhau, nếu phần tử nào nhỏ hơn được đứng vị trí trên','Lần lượt chia dãy phần tử thành hai dãy con bởi một phần tử khoá (dãy con trước khoá gồm các phần tử nhỏ hơn khoá và dãy còn lại gồm các phần tử lớn hơn khoá)','Tạo đống cho cây nhị phân (cây nhị phân đã được sắp xếp giảm dần)','ý tưởng phương pháp sắp xếp vun đống (Heap sort) là',1);
/*!40000 ALTER TABLE `question` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-11-04 18:24:23
